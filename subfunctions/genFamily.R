#####
# Set genFamily function, which generates a vector detailing a family of disease states "Unaffected"/"Sporadic"/"Familial" across time (or at lifetime risk)
# according to various parameters and disease characteristics associated with a var.Chars matrix.
# Primary application is to call genFamilies within lapply() for a population of various sibship sizes (f_sibs)
# var.Chars specifications are generated in varChars function
# Written to prepare simulated data for use in validating the ADPenetrance (https://github.com/ThomasPSpargo/adpenetrance/) approach to calculate genetic penetrance
# Author: Thomas Spargo (thomas.spargo@kcl.ac.uk) 
# Please get in touch if you have any issues.
####

## INPUT:
# f_sibs          = numeric indicating number of siblings to generate within the family. If 0, the family will have 2 individuals, representing two unrelated 'parents'.
# group           = character string of "var" or "novar". Is "var" if one parent harbours a variant of penetrance 'f' as represented within the var.Char matrix. 
#                   Is "novar" if no parent harbours this variant, and thus all family members have lifetime disease risk 'g' as represented within the var.Char matrix, 
# var.Char        = A  matrix in the format generated within the varChars function (The input should have the class 'var.Char.matrix' which is assigned by the varChars function)
#final_time       = Logical, defaults to FALSE. If TRUE, family is generated at a single time point, when all members are assigned the maximum risk according to their variant status
#return_indivs    = Logical, defaults to FALSE. If TRUE, return a more detailed output as a list, indicating (in addition to the overall family disease state) individual family member's age at time 0 and affectedness (1 if affected, 0 if not), at each time of sampling.
#                   If FALSE, only a vector is returned (no list)
#eldestAt0        = Logical, defaults to FALSE. If TRUE, adjusts the family ages such that the eldest parent is assigned age 0 at the first time of sampling,
#                   where 0 is the last time point where no family members could be affected by disease as indicated by risks stored within the var.Char matrix.
#                   If FALSE, the youngest family member is at age 0, and thus at the first time of sampling all other family members have some probability of being affected by disease, according to their variant status and risk indicated in var.Char.
#stepHazard       = Logical, defaults to FALSE. If FALSE, disease risks at each time point are determined using the affAtAge function according to the person's age and variant status (i.e. "var", "novar", or "possvar", where "possvar" are sibs who have a 50% chance of inheriting a variant from a "var" parent)
#                   IF TRUE, disease risk at the first time of sampling are determined using the affAtAge function according to person's age, variant status ("var", "novar", or "possvar").
#                   Thereafter, cumulative risk across each age step is determined based on additional risk between each step of var.Chars across the relevant possible ages of onset and variant status ("var", "novar", or "possvar").
#                   Setting TRUE is not recommended because higher (familial/sporadic) disease state proportions are systematically underrepresented under the 'stepwise' approach.

## OUTPUT:
# If return_indivs=FALSE:
#   A character vector is returned detailing the family affectedness status over time, until the time at which the youngest sib has surpassed the final age at which they might be affected
# If return_indivs=TRUE:
#   A list containing 3 elements:
#   state           = the disease states over time, as when return_indivs=FALSE
#   family          = a matrix detailing family members as rows (with corresponding variant statuses ("novar", "var", and "possvar") as row names) and each individual family member's affectedness (1 if affected, 0 if not), at each time of sampling.

genFamily <- function(f_sibs,group,var.Char,final_time=FALSE,return_indivs=FALSE,eldestAt0=FALSE,stepHazard=FALSE){
  
  if(!"var.Char.matrix" %in% class(var.Char)){ #Expect varChar to be in the format of a matrix output from the varChars function
    stop("Please supply a matrix of the class 'var.Char.matrix', as generated by the varChars() function from ADPenetrance (https://github.com/ThomasPSpargo/adpenetrance/).\nIf generated manually, you can override this error by assigning the class to the object passed to this function: 'class(var.Char) <- c(class(var.Char),\"var.Char.matrix\")'.")
  }
  
  ######
  ### Generate parents and offpring, according to family variant status, and define ages
  ######
  if(group=="var"){ #One parent harbours variant M in the var group
    parents <- c("var","novar")
  } else { #otherwise neither parents has variant
    parents <- c("novar","novar")
  }
  p_age <- 25 #baseline parental age
  if(f_sibs>0){
    if(group=="var"){ #offspring in var group have Mendelian 0.5 probability of inheriting variant, possible variant
      #sibs <- sample(x=c("var","novar"),size=f_sibs,replace=TRUE) #people can also be assigned a variant
      sibs <- rep("possvar",f_sibs)
      
    } else { #otherwise will not
      sibs <- rep("novar",f_sibs)
    }
    
    if(f_sibs>1){ #when more than one sibling, simulate age differences between them
      #Youngest sib is age 0 at time 0
      #Use rnorm around 3 years age gap (SD=0.75) difference between sibling, for N-1 siblings, 
      #Add together estimated gaps to attain ages
      sib_ages<- c(0,rnorm(n=length(sibs)-1,mean=3,sd=0.75))
      for(j in 2:length(sibs)){
        sib_ages[j]<- sib_ages[j]+sib_ages[j-1]
      }
      sib_ages<- round(sib_ages)
    } else { #if only 1 sib, age 0
      sib_ages=0
    }
    
    #Increase parental ages based on having the oldest sib around age 25 (SD = 3)
    p_age <- p_age+max(sib_ages)
  } else { #if no sibs
    
    sibs <- NULL
    sib_ages <- NULL
  }
  p_ages <- rnorm(n=2,mean=p_age,sd=3) #Simulate parental ages based on age 25 baseline and sibling ages
  p_ages <- round(p_ages)
  
  #Create numeric matrix describing entire family, set row and colnames
  family <- matrix(c(p_ages,sib_ages),ncol=1)
  dimnames(family) <- list(c(parents,sibs),"start_age")
  
  #If only sampling at one time point, reassign family ages as the final age, indicative of lifetime Penetrance [minimal testing]
  if(final_time){
    family[,"start_age"] <- max(var.Char[,"step"])
  }
  
  if(eldestAt0){
    family[,"start_age"]  <- family[,"start_age"]-max(family[,"start_age"])
  } else if(f_sibs>0){
    #In N>0 families, shift family by minimum age of family member when siblings are generated
    #This accounts for circumstance where rnorm for siblings produces an extremely young 'elder' sibling, actually younger than the intended 0 sib
    family[,"start_age"]  <- family[,"start_age"]+abs(min(family[,"start_age"])) 
  }
  
  ######
  ### Call function to estimate affected probability at time point 0 (baseline hazard)
  ######
  #Create empty column to store affected status at time 0
  family<- cbind(family,aff_0=rep(NA_real_,rep(nrow(family))))
  
  for(k in 1:nrow(family)){
    #identify inputs, variant status, and age
    vargroup <- rownames(family)[k] 
    startage <- family[k,"start_age"]
    
    #Assign status based on risk at start age
    aff<-affAtAge(vargroup=vargroup,age=startage,var.Char=var.Char)
    
    family[k,"aff_0"] <- aff$status
  }
  
  if(final_time==FALSE){
    ######
    ### Estimate affected probability at time point_j 
    ######
    
    #Estimate the time increments to use [Currently only +1 step integrated]
    time_increment <- var.Char[2,"step"]-var.Char[1,"step"]
    
    if(stepHazard==FALSE){
      #Estimate additional probability of being affected at each step in group f or g
      step_f_prob<- var.Char[2,"f_step"]-var.Char[1,"f_step"] 
      step_g_prob<- var.Char[2,"g_step"]-var.Char[1,"g_step"]
    }
    
    #Loop until all family members surpass the potential onset years
    youngest<- min(family[,"start_age"])
    j <- 0 #set the number of additional years past the start time
    while(youngest<max(var.Char[,"step"])){
      youngest <- youngest+time_increment #incrementally increase time
      j <- j+time_increment
      #Create duplicate of final column, identify the col number represented and name
      family<- cbind(family,family[,ncol(family)])
      colindex <- ncol(family)
      colnames(family)[colindex] <- paste0("aff_",j)
      
      for(k in 1:nrow(family)){
        ##### ASSIGN disease states over time based on cumulative risks across age; having step_f/g_prob risk every age
        current_age<- family[k,"start_age"]+j
        vargroup <- rownames(family)[k] #identify whether or not person has variant
        
        if(stepHazard){    
          #Proceed if the age at time j is <= than the max age of onset and if the person has not yet been affected
          if(current_age<=max(var.Char[,"step"]) && family[k,colindex]==0){
            
            if(vargroup=="novar"){
              step_prob <- step_g_prob
              check_col <- "g_step"
            } else if(vargroup=="var"){
              step_prob <- step_f_prob
              check_col <- "g_propAff"
            } else if(vargroup=="possvar"){
              step_prob <- step_f_prob/2+step_g_prob/2
              check_col <- c("f_propAff","g_propAff")
            }
            
            #Check then whether they have surpassed the age of onset window, if possvar, two windows must be checked
            if (all(var.Char[age_index,check_col]!=0)){
              family[k,colindex] <- rbinom(n=1,size=1,prob=step_prob) #calculate risk at step
            } else if (vargroup=="possvar" && var.Char[age_index,"f_propAff"]==0 && var.Char[age_index,"g_propAff"]!=0){
              family[k,colindex] <- rbinom(n=1,size=1,prob=step_g_prob/2) #calculate risk at step
            } else if (vargroup=="possvar" && var.Char[age_index,"f_propAff"]!=0 && var.Char[age_index,"g_propAff"]==0){
              family[k,colindex] <- rbinom(n=1,size=1,prob=step_f_prob/2) #calculate risk at step
            }
          } #END if current age is below and not affected
        } else if (stepHazard==FALSE){
          #If stephazard is off, repeat the baseline steps at subsequent ages
          
          #Assign status based on risk at current age
          aff<-affAtAge(vargroup=vargroup,age=current_age,var.Char=var.Char)
          
          family[k,colindex] <- aff$status
        } #if stephazard==false
      } #k loop
    } #end while loop
  } #end if(final_time==FALSE){ statement
  
  ######
  ### Identify disease state for family at each time point
  ######
  
  #Extract number affected at time, set 'state' character vector of equal length to number of times
  #As.matrix to force matrix in instance where ncol=2 and a vector is returned by default
  if(ncol(family)==2){
    familyAtTime <- matrix(family[,2:ncol(family)])
  } else {
    familyAtTime <- family[,2:ncol(family)]
  }
  n_affected<- colSums(familyAtTime)
  state <- vector(mode="character",length=length(n_affected))
  
  #Apply state assignments according to n_affected
  state[n_affected>=2] <- "Familial"
  state[n_affected==1] <- "Sporadic"
  state[n_affected==0] <- "Unaffected"
  
  #Finally, return output according to return_indivs argument settings
  if(return_indivs==TRUE){
    return(list(state=state,family=family))
  } else {
    return(state)
  }
} #end function

############ END FUNCTION SPECIFICATION ############

# #Quick functionality test
# Assumes varChars and affAtAge functions are loaded
# 
# #Generate var.Char
# f=0.75
# g=0.00
# numsteps=10
# onsetRateDiff=1
# var.Char<- varChars(f,g,numsteps,onsetRateDiff)
# 
# 
# #Short lapply genFamily for two (small) example populations
# final_time=FALSE
# stepHazard=FALSE
# eldestAt0=FALSE
# return_indivs=FALSE
# 
# aTime <- lapply(0:5,genFamily,group="var",var.Char=var.Char,eldestAt0=eldestAt0,final_time=final_time,stepHazard=stepHazard,return_indivs=return_indivs)
# 
# bTime <- lapply(0:5,genFamily,group="novar",var.Char=var.Char,eldestAt0=eldestAt0,final_time=final_time,stepHazard=stepHazard,return_indivs=return_indivs)
