#####
# Specify affAtAge function, which pseudo-randomly assigns status of a person being affected (1) or not (0) by a disease based on age, variant status, and disease characteristics associated with variant status in a var.Chars matrix.
# var.Chars specifications generated in varChars function
# affAtAge to be called within the genFamily function 
# Written to prepare simulated data for use in validating the ADPenetrance (https://github.com/ThomasPSpargo/adpenetrance/) approach to calculate genetic penetrance
# Author: Thomas Spargo (thomas.spargo@kcl.ac.uk) 
# Please get in touch if you have any issues.
####

## INPUT:
#vargroup       = String indicating individual's variant status which is either "novar","var", or "possvar" (poosvar is a person with 50% chance of being "var" or "novar")
#age            = Age of person relative to the baseline age at which the disease onsets
#                 (age 0 indicates 0 disease risk, age 1+ indicates >0 risk up until max risk according to variant status, as indicated in var.Char)
#var.Char       = A  matrix in the format generated within the varChars function (The input should have the class 'var.Char.matrix' which is assigned by the varChars function)

## OUTPUT:
# A list of two elements:
# status        = numeric of 1 or 0, where 1 = affected by disease and 0 = not affected. These assignments are generated using rbinom with the settings: rbinom(n=1,size=1,prob = getProb). 
# getProb       = numeric of value between 0 and 1, indicating the probability that the individual was affected at a given age, as passed to rbinom to determine status

affAtAge <- function(vargroup,age,var.Char){
  
  if(!"var.Char.matrix" %in% class(var.Char)){ #Expect varChar to be in the format of a matrix output from the varChars function
    stop("Please supply a matrix of the class 'var.Char.matrix', as generated by the varChars() function from ADPenetrance (https://github.com/ThomasPSpargo/adpenetrance/).\nIf generated independently, you can override this error by assigning the class to the object passed to the var.Char argument of this function: 'class(var.Char) <- c(class(var.Char),\"var.Char.matrix\")'.")
  }
  
  #Identify relevant variant status group for person
  if(vargroup=="novar"){
    var_col_index <- "g_step"
  } else if(vargroup=="var"){
    var_col_index <- "f_step"
  } else if(vargroup=="possvar"){
    var_col_index <- c("f_step","g_step")
  }
  
  #Check how risk corresponds to starting age, find index indicating max risk to date according to vargroup
  if(age>=max(var.Char[,"step"])){
    if(vargroup=="possvar"){
      aff_index <- c(which(var.Char[,"f_step"]==max(var.Char[,"f_step"]))[1],
                     which(var.Char[,"g_step"]==max(var.Char[,"g_step"]))[1]
      )
    } else {
      aff_index <- which(var.Char[,var_col_index]==max(var.Char[,var_col_index]))[1]
    }
  } else if(age<=min(var.Char[,"step"])) {
    aff_index <- 1 #Row 1, where there is no risk of being affected
  } else {
    aff_index <- which(var.Char[,"step"]==age) #identify corresponding age
    
    #Ensure risk is not 0, if it is, then max baseline age is passed, assign max instead
    if(vargroup=="novar" && var.Char[aff_index,"g_step"]==0){
      aff_index <- which(var.Char[,"g_step"]==max(var.Char[,"g_step"]))[1]
    } else if(vargroup=="var" && var.Char[aff_index,"f_step"]==0){
      aff_index <- which(var.Char[,"f_step"]==max(var.Char[,"f_step"]))[1]
    } else if (vargroup=="possvar" && (var.Char[aff_index,"f_step"]==0 || var.Char[aff_index,"g_step"]==0)) {
      
      #If either or both groups 0 then assign separately, based on which risk is 0
      if(var.Char[aff_index,"f_step"]==0){
        f_risk <- which(var.Char[,"f_step"]==max(var.Char[,"f_step"]))[1]
      } else {
        f_risk <- aff_index
      }
      
      if(var.Char[aff_index,"g_step"]==0){
        g_risk <- which(var.Char[,"g_step"]==max(var.Char[,"g_step"]))[1]
      } else {
        g_risk <- aff_index
      }
      aff_index <- c(f_risk, g_risk)
    }
  }
  
  #Extract the person's probability of being affected
  if(length(var_col_index)==1){
    #Simple query if only one column
    getProb <- var.Char[aff_index,var_col_index]
  } else if (length(var_col_index)==2) {
    #If 2 columns need to be queried (for people coded possvar), adjust indexing and calculate risk according to both f/2+g/2
    if(length(aff_index)==1){
      aff_index<- c(aff_index,aff_index)
    }  
    fg_half_prob <- vector(mode="numeric",length=2)
    for(i in 1:2){ 
      fg_half_prob[i]<- var.Char[aff_index[i],var_col_index[i]]
    }
    getProb <- sum(fg_half_prob/2) 
  }
  #Assign a disease state based on getProb
  status <- rbinom(n=1,size=1,prob = getProb) 
  
  return(list(status=status,getProb=getProb))
  
}

############ END FUNCTION SPECIFICATION ############

# #Quick functionality test
# Assumes varChars and affAtAge functions are loaded
# 
# #Generate var.Char
# f=0.75
# g=0.00
# numsteps=10
# onsetRateDiff=1
# var.Char<- varChars(f,g,numsteps,onsetRateDiff)
# 
# #Specify other parameters
# vargroup <- "var"
# age <- 3
# 
# #Assign status based on risk at start age
# aff<-affAtAge(vargroup,age,var.Char)
